template:
  - sensor:

#SHOWS CHARGEBOX STATE
      - name: "sem_ev_sensor_state"
        state: >
          {% set sensor_name = states('input_text.sem_ev_sensor_state') %}
          {% if sensor_name and states(sensor_name) not in ['unknown', 'unavailable', None, ''] %}
            {{ states(sensor_name) }}
          {% else %}
            unknown
          {% endif %}

# CHOOSES OFFICIAL OR INOFFICIAL NORDPOOL SENSOR
      - name: "sem_nordpool_sensor_id"
        unique_id: "sem_nordpool_sensor_id"
        state: >
          {%- if is_state('input_boolean.sem_use_official_nordpool', 'on') -%}
            sensor.sem_nordpool_sensor_official
          {%- else -%}
            {{ states('input_text.sem_nordpool_sensor_inofficial') }}
          {%- endif -%}
          
#SHOWS NORDPOOL STATE (NÖDVÄNDIG?)
      - name: "sem_nordpool_sensor_state"
        unit_of_measurement: "SEK/kWh"

        state: >
          {% set sensor_name = states('sensor.sem_nordpool_sensor_id') %}
          {% if sensor_name and states(sensor_name) not in ['unknown', 'unavailable', None, ''] %}
            {{ states(sensor_name) }}
          {% else %}
            unknown
          {% endif %}

#SHOWS ELECTRICPRICE FOR HACS AND OFFICIAL NORDPOOL
      - name: "sem_nordpool_active"
        state: >
          {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
          {% set source = expand(sensor_id) %}
          {% if source | count > 0 %}
            {{ source[0].state }} SEK/kWh
          {% else %}
            unknown
          {% endif %}
        attributes:
          source_sensor: >
            {{ (states('sensor.sem_nordpool_sensor_id') or '') | trim }}
          debug_sensor_exists: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {{ (expand(sensor_id) | count) > 0 }}
          raw_today: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              [
              {% for e in source[0].attributes.get('raw_today', []) %}
                {
                  "start": "{{ e.start.isoformat() }}",
                  "end": "{{ e.end.isoformat() }}",
                  "value": {{ e.value }}
                }{% if not loop.last %},{% endif %}
              {% endfor %}
              ]
            {% else %}
              []
            {% endif %}
          raw_tomorrow: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              [
              {% for e in source[0].attributes.get('raw_tomorrow', []) %}
                {
                  "start": "{{ e.start.isoformat() }}",
                  "end": "{{ e.end.isoformat() }}",
                  "value": {{ e.value }}
                }{% if not loop.last %},{% endif %}
              {% endfor %}
              ]
            {% else %}
              []
            {% endif %}
          today: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              {{ source[0].attributes.get('today', []) }}
            {% else %}
              []
            {% endif %}
          tomorrow: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              {{ source[0].attributes.get('tomorrow', []) }}
            {% else %}
              []
            {% endif %}
          currency: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              {{ source[0].attributes.get('currency', 'SEK') }}
            {% else %}
              'SEK'
            {% endif %}
          tomorrow_valid: >
            {% set sensor_id = (states('sensor.sem_nordpool_sensor_id') or '') | trim %}
            {% set source = expand(sensor_id) %}
            {% if source | count > 0 %}
              {{ source[0].attributes.get('raw_tomorrow') | length > 0 }}
            {% else %}
              false
            {% endif %}



# TRANSLATES WORKING MODE TO SWEDISH
      - name: "sem_battery_mode"
        state: >
          {% set mode = states('select.batteries_working_mode') %}
          {% if mode == 'adaptive' %}
            Adaptiv
          {% elif mode == 'fixed_charge_discharge' %}
            Fast
          {% elif mode == 'maximise_self_consumption' %}
            Självförsörjning
          {% elif mode == 'fully_fed_to_grid' %}
            Export
          {% elif mode == 'time_of_use_luna2000' %}
            Import
          {% else %}
            Okänt läge
          {% endif %}

# CHANGE CHARGING CARD IN UI
      - name: "sem_battery_charging_interval_next"
        state: >
          {% set now_dt = now() %}
          {% set raw_1a = states('sensor.sem_battery_charge_window_cheapest_1a') %}
          {% set raw_2  = states('sensor.sem_battery_charge_window_cheapest_2') %}

          {% set start_1a, end_1a = (raw_1a.split(' - ') if (raw_1a is string and ' - ' in raw_1a) else [none, none]) %}
          {% set start_2,  end_2  = (raw_2.split(' - ')  if (raw_2 is string and ' - ' in raw_2)  else [none, none]) %}

          {% set dt_start_1a = as_datetime(start_1a) if start_1a else none %}
          {% set dt_end_1a   = as_datetime(end_1a)   if end_1a   else none %}
          {% set dt_start_2  = as_datetime(start_2)  if start_2  else none %}
          {% set dt_end_2    = as_datetime(end_2)    if end_2    else none %}

          {% set upcoming = [] %}
          {% if dt_end_1a and dt_end_1a > now_dt %}
                    {% set sort_key = dt_start_1a if (dt_start_1a and dt_start_1a > now_dt) else now_dt %}
                    {% set upcoming = upcoming + [{'name':'1a','sort': sort_key}] %}
          {% endif %}
          {% if dt_end_2 and dt_end_2 > now_dt %}
                    {% set sort_key = dt_start_2 if (dt_start_2 and dt_start_2 > now_dt) else now_dt %}
                    {% set upcoming = upcoming + [{'name':'2','sort': sort_key}] %}
          {% endif %}

          {# Välj närmast (min sort) #}
          {% set sorted_upcoming = upcoming | sort(attribute='sort') %}
          {% set next = sorted_upcoming[0] if sorted_upcoming else none %}

          {% if next and next['name'] == '1a' %}
                    1
          {% else %}
                    2
          {% endif %}

# SOLAR POWER
      - name: "sem_input_power_with_efficiency_loss_kW"
        unique_id: "sem_input_power_with_efficiency_loss_kW"
        unit_of_measurement: "kW"
        device_class: power
        state_class: measurement
        state: >-
          {% set inverter_rating = 10000 %}
          {% set inpower = states('sensor.inverter_input_power') | float(0) %}
          {% if inpower < (inverter_rating * 0.1) %}
              {{ (inpower * 0.90 / 1000) | round(2) }}
          {% elif inpower < (inverter_rating * 0.2) %}
              {{ (inpower * 0.95 / 1000) | round(2) }}
          {% else %}
              {{ (inpower * 0.98 / 1000) | round(2) }}
          {% endif %}       

# HOUSE POWER - NO EV
      - name: "sem_house_power"
        unique_id: sem_house_power
        unit_of_measurement: "kW"
        state: >
          {# === HANTERA NÄT-EFFEKT (Huawei integration) === #}
          {% set net_raw = states('sensor.power_meter_active_power') | float(0) %}
          {% set net_power = net_raw / 1000 if net_raw > 100 else net_raw %}
          {% set import = -net_power if net_power < 0 else 0 %}
          {% set export = net_power if net_power > 0 else 0 %}

          {# === HANTERA EV-LADDNING === #}
          {% set ev_sensor_id = states('input_text.sem_ev_sensor') %}
          {% set ev_raw = states(ev_sensor_id) | float(0) if ev_sensor_id else 0 %}
          {% set ev = ev_raw / 1000 if ev_raw > 100 else ev_raw %}

          {# === SOLPRODUKTION === #}
          {% set solar_raw = states('sensor.sem_input_power_with_efficiency_loss_kW') | float(0) %}
          {% set solar = solar_raw / 1000 if solar_raw > 100 else solar_raw %}

          {# === BATTERI === #}
          {% set batt_raw = states('sensor.batteries_charge_discharge_power') | float(0) %}
          {% set batt = batt_raw / 1000 if batt_raw > 100 else batt_raw %}
          {% set batt_out = -batt if batt < 0 else 0 %}
          {% set batt_in = batt if batt > 0 else 0 %}

          {# === HUSFÖRBRUKNING === #}
          {% set house_power = (solar + import + batt_out) - (export + ev + batt_in) %}

          {{ [house_power, 0] | max | round(2) }}


# CALCULATES CHARGE TIME FROM MAX kW
      - name: "sem_battery_dynamic_charge_time_window_1"
        unit_of_measurement: "h"
        state: >
          {# 
          Beräknar laddningstid för laddningsfönster 1 (kl. 9-16)
          baserat på tillåten maxeffekt i input_number.sem_max_charge_power_window_1,
          men högst 5 timmar.
          #}
          {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
          {% set max_power_kw = states('input_number.sem_max_charge_power_window_1') | float(0) %}
          {% if max_power_kw > 0 %}
            {{ [ (capacity / max_power_kw) | round(1), 5 ] | min }}
          {% else %}
            0
          {% endif %}


# CALCULATES CHARGE TIME FROM MAX kW
      - name: "sem_battery_dynamic_charge_time_window_2"
        unit_of_measurement: "h"
        state: >
          {# 
          Beräknar laddningstid för laddningsfönster 2 (kl. 23–05)
          baserat på tillåten maxeffekt i input_number.sem_max_charge_power_window_2,
          men högst 5 timmar.
          #}
          {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
          {% set max_power_kw = states('input_number.sem_max_charge_power_window_2') | float(0) %}
          {% if max_power_kw > 0 %}
            {{ [ (capacity / max_power_kw) | round(1), 5 ] | min }}
          {% else %}
            0
          {% endif %}


# CALCULATES ENERGY BETWEEN 1A AND 2
      - name: "sem_battery_charge_energy_1a_2"
        unique_id: sem_battery_charge_energy_1a_2
        unit_of_measurement: "kWh"
        state: >
          {% set battery_capacity = state_attr('sensor.sem_battery_charge_energy_1a_2','battery_capacity') | float(0) %} 
          {% set usable_capacity = state_attr('sensor.sem_battery_charge_energy_1a_2','usable_capacity') | float(0) %} 
          {% set buffer = states('input_number.sem_battery_buffer_kwh') | float(0) %} 
          {% set estimated_energy_sun_interval = state_attr('sensor.sem_battery_charge_energy_1a_2','estimated_energy_sun_interval') | float(0) %} 
          {% set estimated_solar_energy = state_attr('sensor.sem_battery_charge_energy_1a_2','estimated_solar_energy') | float(0) %} 
          {% set estimated_energy_no_sun_interval = state_attr('sensor.sem_battery_charge_energy_1a_2','estimated_energy_no_sun_interval') | float(0) %} 
          {% set avg_price_charge_window = state_attr('sensor.sem_battery_charge_energy_1a_2','avg_price') | float(0) %} 
          {% set price_limit_supercheap = states('input_number.sem_price_limit_supercheap') | float(0) %} 
          {% set supercheap_charge = state_attr('sensor.sem_battery_charge_energy_1a_2','supercheap_charge') | float(0) %}
          {% set extra = states('input_number.extra_1') | float(0) %}
          {% set adjustment_factor_solar_energy = state_attr('sensor.sem_battery_charge_energy_1a_2','adjustment_factor_solar_energy') | float(0) %}


          {% set solar_diff = [estimated_energy_sun_interval - (estimated_solar_energy * adjustment_factor_solar_energy) , 0] | max %}
          {% set raw_total = (estimated_energy_no_sun_interval + solar_diff + buffer) - battery_capacity %}
          {% set total_energy_need = [raw_total, 0] | max %}


          {{ (total_energy_need + supercheap_charge + extra) | round(2) }}
        attributes:
            search_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}
                  {{ start.isoformat() }} - {{ end.isoformat() }}
            sun_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}

                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}

                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_start = none %}
                  {% set solar_interval_end = none %}

                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                          | selectattr('date', 'defined')
                          | selectattr('date', '>=', start_ts | timestamp_local)
                          | selectattr('date', '<=', end_ts | timestamp_local)
                          | selectattr('date', 'match', '^' ~ today_date|string)
                          | list %}
                        {% set valid_entries = entries
                          | selectattr('values', 'defined')
                          | selectattr('values', '>', 0)
                          | list %}

                        {% if valid_entries | length > 0 %}
                              {% set solar_interval_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                              {% set solar_interval_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                        {% endif %}
                  {% endif %}

                  {% if solar_interval_start and solar_interval_end %}
                        {{ solar_interval_start.isoformat() }} - {{ solar_interval_end.isoformat() }}
                  {% else %}
                        {{ '1970-01-01T00:00:00+00:00 - 1970-01-01T00:00:00+00:00' }}
                  {% endif %}
            no_sun_interval: >
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_end = none %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                          | selectattr('date', 'defined')
                          | selectattr('date', '>=', start_ts | timestamp_local)
                          | selectattr('date', '<=', end_ts | timestamp_local)
                          | selectattr('date', 'match', '^' ~ today_date|string)
                          | list %}
                        {% set valid_entries = entries
                          | selectattr('values', 'defined')
                          | selectattr('values', '>', 0)
                          | list %}
                        {% if valid_entries | length > 0 %}
                              {% set solar_interval_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                        {% endif %}
                  {% endif %}
                  {% if solar_interval_end %}
                        {{ solar_interval_end.isoformat() }} - {{ end.isoformat() }}
                  {% else %}
                        1970-01-01T00:00:00+00:00 - 1970-01-01T00:00:00+00:00
                  {% endif %}
            battery_capacity: >
                  {# Visar aktuell laddning i kWh min SoC (dvs det som faktiskt är användbart) #}
                  {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
                  {% set soc = states('sensor.batteries_state_of_capacity') | float(0) %}
                  {% set min_soc = states('number.batteries_end_of_discharge_soc') | float(0) %}
                  {% set denom = (100 - min_soc) %}
                  {% if denom <= 0 %}
                        {{ 0.0 }}
                  {% else %}
                        {% set usable_capacity = capacity * ((100 - min_soc) / 100) %}
                        {% set soc_clamped = soc %}
                        {% if soc_clamped < min_soc %}
                              {% set soc_clamped = min_soc %}
                        {% endif %}
                        {% if soc_clamped > 100 %}
                              {% set soc_clamped = 100 %}
                        {% endif %}
                        {% set current_kwh = usable_capacity * ((soc_clamped - min_soc) / denom) %}
                        {{ current_kwh | round(2) }}
                  {% endif %}
            usable_capacity: >
                  {# Total användbar kapacitet (kWh) givet min SoC #}
                  {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
                  {% set min_soc = states('number.batteries_end_of_discharge_soc') | float(0) %}
                  {% set denom = (100 - min_soc) %}
                  {% if denom <= 0 %}
                        {{ 0.0 }}
                  {% else %}
                        {{ (capacity * ((100 - min_soc) / 100)) | round(2) }}
                  {% endif %}
            buffer: >
                  {% set buffer = states('input_number.sem_battery_buffer_kwh') | float(0) %}
                  {{ buffer | round(2) }}
            extra: >
                  {% set extra = states('input_number.extra_1') | float(0) %}
                  {{ extra | round(2) }}
            supercheap_charge: >
                  {# --- Beräkna medelpris för laddningsintervallet (kvartpris) --- #}
                  {% set interval_raw = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set avg_price = 99 %}
                  {% if interval_raw and ' - ' in interval_raw %}
                  {% set start_dt = as_datetime(interval_raw.split(' - ')[0]) %}
                  {% set end_dt = as_datetime(interval_raw.split(' - ')[1]) %}
                  {% set raw_today = state_attr('sensor.sem_nordpool_sensor_id','raw_today') or [] %}
                  {% set raw_tomorrow = state_attr('sensor.sem_nordpool_sensor_id','raw_tomorrow') or [] %}
                  {% set tomorrow_valid = state_attr('sensor.sem_nordpool_sensor_id','tomorrow_valid') == true %}
                  {% set ns = namespace(total=0.0, count=0) %}

                  {% set quarters = ((end_dt - start_dt).total_seconds() // 900) | int %}

                  {% for i in range(quarters) %}
                  {% set t = start_dt + timedelta(minutes=i*15) %}
                  {% set index = t.hour*4 + (t.minute // 15) %}
                  {% if t.date() == now().date() %}
                  {% set p = raw_today[index].value if raw_today|length > index else None %}
                  {% elif tomorrow_valid and t.date() == (now().date() + timedelta(days=1)) %}
                  {% set p = raw_tomorrow[index].value if raw_tomorrow|length > index else None %}
                  {% else %}
                  {% set p = None %}
                  {% endif %}
                  {% if p is not none %}
                  {% set ns.total = ns.total + (p|string|replace(',','.')|float(0)) %}
                  {% set ns.count = ns.count + 1 %}
                  {% endif %}
                  {% endfor %}

                  {% if ns.count > 0 %}
                  {% set avg_price = ns.total / ns.count %}
                  {% endif %}
                  {% endif %}

                  {# --- Värden för beräkningen --- #}
                  {% set price_limit_supercheap = states('input_number.sem_price_limit_supercheap') | float(0) %}
                  {% set battery_capacity = state_attr('sensor.sem_battery_charge_energy_1a_2','battery_capacity') | float(0) %}
                  {% set usable_capacity = state_attr('sensor.sem_battery_charge_energy_1a_2','usable_capacity') | float(0) %}
                  {% set soc = states('sensor.batteries_state_of_capacity') | float(0) %}
                  {% set max_buffer_pct = 0.50 %}
                  {% set min_buffer_pct = 0.05 %}

                  {# --- Beräkning av extra kWh vid superbilligt --- #}
                  {% if soc < 80 %}
                  {% set buffer_pct = min_buffer_pct + (max_buffer_pct - min_buffer_pct) * (1 - soc/80) %}
                  {% set buffer_kwh = usable_capacity * buffer_pct %}
                  {% else %}
                  {% set buffer_kwh = 0 %}
                  {% endif %}

                  {# --- Returnera kWh att ladda vid superbilligt pris --- #}
                  {% if avg_price < price_limit_supercheap %}
                  {{ buffer_kwh | round(2) }}
                  {% else %}
                  0
                  {% endif %}
            price_limit_supercheap: >
                  {% set buffer = states('input_number.sem_price_limit_supercheap') | float(0) %}
                  {{ buffer | round(2) }}
            estimated_energy_sun_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}

                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_start = none %}
                  {% set solar_interval_end = none %}

                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                              | selectattr('date', 'defined')
                              | selectattr('date', '>=', start_ts | timestamp_local)
                              | selectattr('date', '<=', end_ts | timestamp_local)
                              | selectattr('date', 'match', '^' ~ today_date|string)
                              | list %}
                        {% set valid_entries = entries
                              | selectattr('values', 'defined')
                              | selectattr('values', '>', 0)
                              | list %}
                        {% if valid_entries | length > 0 %}
                              {% set solar_interval_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                              {% set solar_interval_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                        {% endif %}
                  {% endif %}

                  {% set s_start = solar_interval_start %}
                  {% set s_end = solar_interval_end %}

                  {% set sensors = {
                        'morning': (5, 10, states('sensor.sem_energy_avg_morning') | float(0)),
                        'day': (10, 15, states('sensor.sem_energy_avg_day') | float(0)),
                        'evening': (15, 21, states('sensor.sem_energy_avg_evening') | float(0)),
                        'night_evening': (22, 0, states('sensor.sem_energy_avg_night') | float(0)),
                        'night_morning': (0, 5, states('sensor.sem_energy_avg_night') | float(0))
                  } %}

                  {% set ns = namespace(kwh=0) %}

                  {% if s_start and s_end %}
                        {% for block, (h_start, h_end, effect) in sensors.items() %}
                              {% set block_start = s_start.replace(hour=h_start % 24, minute=0, second=0, microsecond=0) %}
                              {% set block_end = s_start.replace(hour=h_end % 24, minute=0, second=0, microsecond=0) %}
                              {% if h_start >= h_end and block_end <= block_start %}
                                    {% set block_end = block_end + timedelta(days=1) %}
                              {% endif %}
                              {% set overlap_start = [s_start, block_start] | max %}
                              {% set overlap_end = [s_end, block_end] | min %}
                              {% set delta = (overlap_end - overlap_start).total_seconds() / 3600 %}
                              {% if delta > 0 %}
                                    {% set ns.kwh = ns.kwh + delta * effect %}
                              {% endif %}
                        {% endfor %}
                  {% endif %}

                  {{ ns.kwh | round(2) }}
            estimated_solar_energy: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[1] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_kwh = 0 %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                              | selectattr('date', 'defined')
                              | selectattr('date', '>=', start_ts | timestamp_local)
                              | selectattr('date', '<=', end_ts | timestamp_local)
                              | selectattr('date', 'match', '^' ~ today_date|string)
                              | list %}
                        {% set valid_entries = entries
                              | selectattr('values', 'defined')
                              | selectattr('values', '>', 0)
                              | list %}
                        {% if valid_entries | length > 0 %}
                              {% set solar_kwh = (valid_entries | map(attribute='values') | sum | default(0)) / 1000 * 0.9 %}
                        {% endif %}
                  {% endif %}
                  {{ solar_kwh | round(2) }}
            adjustment_factor_solar_energy: >
                  {% set forecast = state_attr('sensor.sem_weather_forecasts_hourly', 'forecast') %}
                  {% set interval_str = state_attr('sensor.sem_battery_charge_energy_1a_2','search_interval') %}
                  {% if forecast and interval_str %}
                    {% set start_str = interval_str.split(' - ')[0] %}
                    {% set end_str   = interval_str.split(' - ')[1] %}
                    {% set future = forecast
                      | selectattr('datetime', 'defined')
                      | selectattr('datetime', '!=', None)
                      | selectattr('datetime', '>=', start_str)
                      | selectattr('datetime', '<=', end_str)
                      | list %}
              
                    {% if future | length > 0 %}
                      {% set avg_clouds = (future | map(attribute='cloud_coverage') | select('defined') | map('float') | list | average(0)) %}
                      {% set conditions = future | map(attribute='condition') | list %}
                     {% set cloud_factor = 1 - (avg_clouds / 100 * 0.7) %}
                
                      {% set rain = conditions | select('search', 'rain') | list | count %}
                      {% set snow = conditions | select('search', 'snow') | list | count %}
                    {% set cloudy = conditions | select('search', 'cloudy') | list | count %}
                      {% set partly = conditions | select('search', 'partlycloudy') | list | count %}
                
                      {% if rain > 0 %}
                        {% set weather_factor = 0.6 %}
                      {% elif snow > 0 %}
                        {% set weather_factor = 0.5 %}
                      {% elif partly > 0 %}
                        {% set weather_factor = 0.9 %}
                      {% elif cloudy > 0 %}
                        {% set weather_factor = 0.8 %}
                      {% else %}
                      {% set weather_factor = 1.0 %}
                      {% endif %}
                
                      {{ (cloud_factor * weather_factor) | round(2) }}
                    {% else %}
                      1
                    {% endif %}
                  {% else %}
                    1
                  {% endif %}
            estimated_energy_no_sun_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_end = none %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                              | selectattr('date', 'defined')
                              | selectattr('date', '>=', start_ts | timestamp_local)
                              | selectattr('date', '<=', end_ts | timestamp_local)
                              | selectattr('date', 'match', '^' ~ today_date|string)
                              | list %}
                        {% set valid_entries = entries
                              | selectattr('values', 'defined')
                              | selectattr('values', '>', 0)
                              | list %}
                        {% if valid_entries | length > 0 %}
                              {% set solar_interval_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                        {% endif %}
                  {% endif %}
                  {% set s_start = solar_interval_end %}
                  {% set s_end = end %}
                  {% set sensors = {
                        'morning': (5, 10, states('sensor.sem_energy_avg_morning') | float(0)),
                        'day': (10, 15, states('sensor.sem_energy_avg_day') | float(0)),
                        'evening': (15, 21, states('sensor.sem_energy_avg_evening') | float(0)),
                        'night_evening': (22, 0, states('sensor.sem_energy_avg_night') | float(0)),
                        'night_morning': (0, 5, states('sensor.sem_energy_avg_night') | float(0))
                  } %}
                  {% set ns = namespace(kwh=0) %}
                  {% if s_start and s_end %}
                        {% for block, (h_start, h_end, effect) in sensors.items() %}
                              {% set block_start = s_start.replace(hour=h_start % 24, minute=0, second=0, microsecond=0) %}
                              {% set block_end = s_start.replace(hour=h_end % 24, minute=0, second=0, microsecond=0) %}
                              {% if h_start >= h_end and block_end <= block_start %}
                                    {% set block_end = block_end + timedelta(days=1) %}
                              {% endif %}
                              {% if block_start < s_start %}
                                    {% set block_start = block_start + timedelta(days=1) %}
                              {% endif %}
                              {% if block_end < s_start %}
                                    {% set block_end = block_end + timedelta(days=1) %}
                              {% endif %}
                              {% set overlap_start = [s_start, block_start] | max %}
                              {% set overlap_end = [s_end, block_end] | min %}
                              {% set delta = (overlap_end - overlap_start).total_seconds() / 3600 %}
                              {% if delta > 0 %}
                                    {% set ns.kwh = ns.kwh + delta * effect %}
                              {% endif %}
                        {% endfor %}
                  {% endif %}
                  {{ ns.kwh | round(2) }}

# CALCULATES ENERGY BETWEEN 2 AND 1B
      - name: "sem_battery_charge_energy_2_1b"
        unique_id: sem_battery_charge_energy_2_1b
        unit_of_measurement: "kWh"
        state: >
            {% set battery_capacity = state_attr('sensor.sem_battery_charge_energy_2_1b','battery_capacity') | float(0) %} 
            {% set usable_capacity = state_attr('sensor.sem_battery_charge_energy_2_1b','usable_capacity ') | float(0) %} 
            {% set buffer = states('input_number.sem_battery_buffer_kwh') | float(0) %} 
            {% set estimated_energy_sun_interval = state_attr('sensor.sem_battery_charge_energy_2_1b','estimated_energy_sun_interval') | float(0) %} 
            {% set estimated_solar_energy = state_attr('sensor.sem_battery_charge_energy_2_1b','estimated_solar_energy') | float(0) %} 
            {% set estimated_energy_no_sun_interval = state_attr('sensor.sem_battery_charge_energy_2_1b','estimated_energy_no_sun_interval') | float(0) %} 
            {% set avg_price_charge_window = state_attr('sensor.sem_battery_charge_energy_2_1b','avg_price') | float(0) %} 
            {% set price_limit_supercheap = states('input_number.sem_price_limit_supercheap') | float(0) %} 
            {% set supercheap_charge = state_attr('sensor.sem_battery_charge_energy_2_1b','supercheap_charge') | float(0) %}
            {% set extra = states('input_number.extra_2') | float(0) %} 
            {% set adjustment_factor_solar_energy = state_attr('sensor.sem_battery_charge_energy_2_1b','adjustment_factor_solar_energy') | float(0) %}

            {% set solar_diff = [estimated_energy_sun_interval - (estimated_solar_energy * adjustment_factor_solar_energy) , 0] | max %}
            {% set raw_total = (estimated_energy_no_sun_interval + solar_diff + buffer) - battery_capacity %}
            {% set total_energy_need = [raw_total, 0] | max %}


            {{ (total_energy_need + supercheap_charge + extra) | round(2) }}
        attributes:
            search_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_1a') %}
                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}
                  {{ start.isoformat() }} - {{ end.isoformat() }}
            sun_interval: >
                  {% set raw_start = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% set raw_end = states('sensor.sem_battery_charge_window_cheapest_1a') %}

                  {% if ' - ' in raw_start and ' - ' in raw_end %}
                        {% set t1 = raw_start.split(' - ')[0] %}
                        {% set t2 = raw_end.split(' - ')[0] %}
                        {% set start = as_datetime(t1) %}
                        {% set end = as_datetime(t2) %}
                  {% else %}
                        {% set start = as_datetime('1970-01-01T00:00:00+00:00') %}
                        {% set end = as_datetime('1970-01-01T01:00:00+00:00') %}
                  {% endif %}

                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_start = none %}
                  {% set solar_interval_end = none %}

                  {% if forecast and 'watt_hours_period' in forecast %}
                        {% set start_ts = as_timestamp(start) %}
                        {% set end_ts = as_timestamp(end) %}
                        {% set today_date = start.date() %}
                        {% set entries = forecast['watt_hours_period']
                          | selectattr('date', 'defined')
                          | selectattr('date', '>=', start_ts | timestamp_local)
                          | selectattr('date', '<=', end_ts | timestamp_local)
                          | selectattr('date', 'match', '^' ~ today_date|string)
                          | list %}
                        {% set valid_entries = entries
                          | selectattr('values', 'defined')
                          | selectattr('values', '>', 0)
                          | list %}

                        {% if valid_entries | length > 0 %}
                              {% set solar_interval_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                              {% set solar_interval_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                        {% endif %}
                  {% endif %}

                  {% if solar_interval_start and solar_interval_end %}
                        {{ solar_interval_start.isoformat() }} - {{ solar_interval_end.isoformat() }}
                  {% else %}
                        {{ '1970-01-01T00:00:00+00:00 - 1970-01-01T00:00:00+00:00' }}
                  {% endif %}
            no_sun_interval: >
                  {% set t1 = states('sensor.sem_battery_charge_window_cheapest_2').split(' - ')[0] %}
                  {% set start = as_datetime(t1) %}
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set solar_interval_start = none %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                                {% set start_ts = as_timestamp(start) %}
                                {% set entries = forecast['watt_hours_period']
                                      | selectattr('date', 'defined')
                                      | selectattr('date', '>=', start_ts | timestamp_local)
                                      | list %}
                                {% set valid_entries = entries
                                      | selectattr('values', 'defined')
                                      | selectattr('values', '>', 0)
                                      | list %}
                                {% if valid_entries | length > 0 %}
                                      {% set solar_interval_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                                {% endif %}
                  {% endif %}
                  {% if solar_interval_start %}
                                {{ start.isoformat() }} - {{ solar_interval_start.isoformat() }}
                  {% else %}
                                1970-01-01T00:00:00+00:00 - 1970-01-01T00:00:00+00:00
                  {% endif %}
            battery_capacity: >
                  {# Visar aktuell laddning i kWh min SoC (dvs det som faktiskt är användbart) #}
                  {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
                  {% set soc = states('sensor.batteries_state_of_capacity') | float(0) %}
                  {% set min_soc = states('number.batteries_end_of_discharge_soc') | float(0) %}
                  {% set denom = (100 - min_soc) %}
                  {% if denom <= 0 %}
                        {{ 0.0 }}
                  {% else %}
                        {% set usable_capacity = capacity * ((100 - min_soc) / 100) %}
                        {% set soc_clamped = soc %}
                        {% if soc_clamped < min_soc %}
                              {% set soc_clamped = min_soc %}
                        {% endif %}
                        {% if soc_clamped > 100 %}
                              {% set soc_clamped = 100 %}
                        {% endif %}
                        {% set current_kwh = usable_capacity * ((soc_clamped - min_soc) / denom) %}
                        {{ current_kwh | round(2) }}
                  {% endif %}
            usable_capacity: >
                  {# Total användbar kapacitet (kWh) givet min SoC #}
                  {% set capacity = states('input_number.sem_battery_total_capacity_kwh') | float(0) %}
                  {% set min_soc = states('number.batteries_end_of_discharge_soc') | float(0) %}
                  {% set denom = (100 - min_soc) %}
                  {% if denom <= 0 %}
                        {{ 0.0 }}
                  {% else %}
                        {{ (capacity * ((100 - min_soc) / 100)) | round(2) }}
                  {% endif %}
            buffer: >
                  {% set buffer = states('input_number.sem_battery_buffer_kwh') | float(0) %}
                  {{ buffer | round(2) }}
            extra: >
                  {% set extra = states('input_number.extra_2') | float(0) %}
                  {{ extra | round(2) }}
            supercheap_charge: >
                  {# --- Beräkna medelpris för laddningsintervallet (kvartpris) --- #}
                  {% set interval_raw = states('sensor.sem_battery_charge_window_cheapest_2') %}
                  {% set avg_price = 99 %}
                  {% if interval_raw and ' - ' in interval_raw %}
                  {% set start_dt = as_datetime(interval_raw.split(' - ')[0]) %}
                  {% set end_dt = as_datetime(interval_raw.split(' - ')[1]) %}
                  {% set raw_today = state_attr('sensor.sem_nordpool_sensor_id','raw_today') or [] %}
                  {% set raw_tomorrow = state_attr('sensor.sem_nordpool_sensor_id','raw_tomorrow') or [] %}
                  {% set tomorrow_valid = state_attr('sensor.sem_nordpool_sensor_id','tomorrow_valid') == true %}
                  {% set ns = namespace(total=0.0, count=0) %}

                  {% set quarters = ((end_dt - start_dt).total_seconds() // 900) | int %}

                  {% for i in range(quarters) %}
                  {% set t = start_dt + timedelta(minutes=i*15) %}
                  {% set index = t.hour*4 + (t.minute // 15) %}
                  {% if t.date() == now().date() %}
                  {% set p = raw_today[index].value if raw_today|length > index else None %}
                  {% elif tomorrow_valid and t.date() == (now().date() + timedelta(days=1)) %}
                  {% set p = raw_tomorrow[index].value if raw_tomorrow|length > index else None %}
                  {% else %}
                  {% set p = None %}
                  {% endif %}
                  {% if p is not none %}
                  {% set ns.total = ns.total + (p|string|replace(',','.')|float(0)) %}
                  {% set ns.count = ns.count + 1 %}
                  {% endif %}
                  {% endfor %}

                  {% if ns.count > 0 %}
                  {% set avg_price = ns.total / ns.count %}
                  {% endif %}
                  {% endif %}

                  {# --- Värden för beräkningen --- #}
                  {% set price_limit_supercheap = states('input_number.sem_price_limit_supercheap') | float(0) %}
                  {% set battery_capacity = state_attr('sensor.sem_battery_charge_energy_2_1b','battery_capacity') | float(0) %}
                  {% set usable_capacity = state_attr('sensor.sem_battery_charge_energy_2_1b','usable_capacity') | float(0) %}
                  {% set soc = states('sensor.batteries_state_of_capacity') | float(0) %}
                  {% set max_buffer_pct = 0.50 %}
                  {% set min_buffer_pct = 0.05 %}

                  {# --- Beräkning av extra kWh vid superbilligt --- #}
                  {% if soc < 80 %}
                  {% set buffer_pct = min_buffer_pct + (max_buffer_pct - min_buffer_pct) * (1 - soc/80) %}
                  {% set buffer_kwh = usable_capacity * buffer_pct %}
                  {% else %}
                  {% set buffer_kwh = 0 %}
                  {% endif %}

                  {# --- Returnera kWh att ladda vid superbilligt pris --- #}
                  {% if avg_price < price_limit_supercheap %}
                  {{ buffer_kwh | round(2) }}
                  {% else %}
                  0
                  {% endif %}
            price_limit_supercheap: >
                  {% set buffer = states('input_number.sem_price_limit_supercheap') | float(0) %}
                  {{ buffer | round(2) }}
            estimated_energy_sun_interval: >
                  {% set t1 = states('sensor.sem_battery_charge_window_cheapest_2').split(' - ')[0] %}
                  {% set t2 = states('sensor.sem_battery_charge_window_cheapest_1a').split(' - ')[0] %}
                  {% set start = as_datetime(t1) %}
                  {% set end = as_datetime(t2) %}
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set s_start = none %}
                  {% set s_end = none %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                    {% set start_ts = as_timestamp(start) %}
                    {% set end_ts = as_timestamp(end) %}
                    {% set entries = forecast['watt_hours_period']
                      | selectattr('date', 'defined')
                      | selectattr('date', '>=', start_ts | timestamp_local)
                      | selectattr('date', '<=', end_ts | timestamp_local)
                      | list %}
                    {% set valid_entries = entries
                      | selectattr('values', 'defined')
                      | selectattr('values', '>', 0)
                      | list %}
                    {% if valid_entries | length > 0 %}
                      {% set s_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                      {% set s_end = (valid_entries[-1].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                    {% endif %}
                  {% endif %}

                  {% set sensors = {
                    'morning': (5, 10, states('sensor.sem_energy_avg_morning') | float(0)),
                    'day': (10, 15, states('sensor.sem_energy_avg_day') | float(0)),
                    'evening': (15, 22, states('sensor.sem_energy_avg_evening') | float(0)),
                    'night_evening': (22, 24, states('sensor.sem_energy_avg_night') | float(0)),
                    'night_morning': (0, 5, states('sensor.sem_energy_avg_night') | float(0))
                  } %}
                  {% set ns = namespace(kwh=0) %}

                  {% if s_start and s_end %}
                    {% for block, (h_start, h_end, effect) in sensors.items() %}
                      {% set block_start = s_start.replace(hour=h_start % 24, minute=0, second=0, microsecond=0) %}
                      {% set block_end = s_start.replace(hour=h_end % 24, minute=0, second=0, microsecond=0) %}
                      {% if h_start >= h_end and block_start <= block_end %}
                        {% set block_end = block_end + timedelta(days=1) %}
                      {% endif %}
                      {% set overlap_start = [s_start, block_start] | max %}
                      {% set overlap_end = [s_end, block_end] | min %}
                      {% set delta = (overlap_end - overlap_start).total_seconds() / 3600 %}
                      {% if delta > 0 %}
                        {% set ns.kwh = ns.kwh + delta * effect %}
                      {% endif %}
                    {% endfor %}
                  {% endif %}

                  {{ ns.kwh | round(2) }}
            estimated_solar_energy: >
                  {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                  {% set t1 = states('sensor.sem_battery_charge_window_cheapest_2').split(' - ')[0] %}
                  {% set t2 = states('sensor.sem_battery_charge_window_cheapest_1a').split(' - ')[0] %}
                  {% set start = as_datetime(t1) %}
                  {% set end = as_datetime(t2) %}
                  {% set solar_kwh = 0 %}
                  {% if forecast and 'watt_hours_period' in forecast %}
                                {% set start_ts = as_timestamp(start) %}
                                {% set end_ts = as_timestamp(end) %}
                                {% set entries = forecast['watt_hours_period']
                                      | selectattr('date', 'defined')
                                      | selectattr('date', '>=', start_ts | timestamp_local)
                                      | selectattr('date', '<=', end_ts | timestamp_local)
                                      | list %}
                                {% set valid_entries = entries
                                      | selectattr('values', 'defined')
                                      | selectattr('values', '>', 0)
                                      | list %}
                                {% if valid_entries | length > 0 %}
                                          {% set solar_kwh = (valid_entries | map(attribute='values') | sum | default(0)) / 1000 * 0.9 %}
                                {% endif %}
                  {% endif %}
                  {{ solar_kwh | round(2) }}
            adjustment_factor_solar_energy: >
                  {% set forecast = state_attr('sensor.sem_weather_forecasts_hourly', 'forecast') %}
                  {% set interval_str = state_attr('sensor.sem_battery_charge_energy_2_1b','search_interval') %}
                  {% if forecast and interval_str %}
                    {% set start_str = interval_str.split(' - ')[0] %}
                    {% set end_str   = interval_str.split(' - ')[1] %}
                    {% set future = forecast
                      | selectattr('datetime', 'defined')
                      | selectattr('datetime', '!=', None)
                      | selectattr('datetime', '>=', start_str)
                      | selectattr('datetime', '<=', end_str)
                      | list %}
              
                    {% if future | length > 0 %}
                      {% set avg_clouds = (future | map(attribute='cloud_coverage') | select('defined') | map('float') | list | average(0)) %}
                      {% set conditions = future | map(attribute='condition') | list %}
                      {% set cloud_factor = 1 - (avg_clouds / 100 * 0.7) %}
                
                      {% set rain = conditions | select('search', 'rain') | list | count %}
                      {% set snow = conditions | select('search', 'snow') | list | count %}
                      {% set cloudy = conditions | select('search', 'cloudy') | list | count %}
                      {% set partly = conditions | select('search', 'partlycloudy') | list | count %}
                
                      {% if rain > 0 %}
                        {% set weather_factor = 0.6 %}
                      {% elif snow > 0 %}
                        {% set weather_factor = 0.5 %}
                      {% elif partly > 0 %}
                        {% set weather_factor = 0.9 %}
                      {% elif cloudy > 0 %}
                        {% set weather_factor = 0.8 %}
                      {% else %}
                        {% set weather_factor = 1.0 %}
                      {% endif %}
                
                      {{ (cloud_factor * weather_factor) | round(2) }}
                    {% else %}
                      1
                    {% endif %}
                  {% else %}
                    1
                  {% endif %}
            estimated_energy_no_sun_interval: >
                    {% set t1 = states('sensor.sem_battery_charge_window_cheapest_2').split(' - ')[0] %}
                    {% set start = as_datetime(t1) %}
                    {% set forecast = state_attr('sensor.sem_solar_forecast', 'sem') %}
                    {% set s_start = none %}

                    {% if forecast and 'watt_hours_period' in forecast %}
                              {% set entries = forecast['watt_hours_period']
                                | selectattr('date', 'defined')
                                | selectattr('date', '>=', as_timestamp(start) | timestamp_local)
                                | list %}
                              {% set valid_entries = entries
                                | selectattr('values', 'defined')
                                | selectattr('values', '>', 0)
                                | list %}
                              {% if valid_entries | length > 0 %}
                                        {% set s_start = (valid_entries[0].date | as_datetime).replace(minute=0, second=0, microsecond=0) %}
                              {% endif %}
                    {% endif %}

                    {% set end = s_start if s_start else start %}

                    {% set sensors = {
                              'morning': (5, 10, states('sensor.sem_energy_avg_morning') | float(0)),
                              'day': (10, 15, states('sensor.sem_energy_avg_day') | float(0)),
                              'evening': (15, 22, states('sensor.sem_energy_avg_evening') | float(0)),
                              'night_evening': (22, 24, states('sensor.sem_energy_avg_night') | float(0)),
                              'night_morning': (0, 5, states('sensor.sem_energy_avg_night') | float(0))
                    } %}

                    {% set ns = namespace(kwh=0) %}

                    {% for block, (h_start, h_end, effect) in sensors.items() %}
                              {% set b_start = start.replace(hour=h_start % 24, minute=0, second=0, microsecond=0) %}
                              {% set b_end = b_start.replace(hour=h_end % 24) %}

                              {# Midnattblock hanteras #}
                              {% if h_start >= h_end %}
                                        {% set b_end = b_end + timedelta(days=1) %}
                              {% endif %}

                              {# Flytta block framåt om det ligger helt före intervallet #}
                              {% if b_end <= start %}
                                        {% set b_start = b_start + timedelta(days=1) %}
                                        {% set b_end = b_end + timedelta(days=1) %}
                              {% endif %}

                              {% set overlap_start = [start, b_start] | max %}
                              {% set overlap_end = [end, b_end] | min %}
                              {% set delta = (overlap_end - overlap_start).total_seconds() / 3600 %}

                              {% if delta > 0 %}
                                        {% set ns.kwh = ns.kwh + delta * effect %}
                              {% endif %}
                    {% endfor %}

                    {{ ns.kwh | round(2) }}        

# BUILDS A NORDPOOL SENSOR WITH THE OFFICIAL INTEGRATION
  - trigger:
      - trigger: time_pattern
        minutes: /15
      - trigger: homeassistant
        event: start
#    conditions:
#      - condition: state
#        entity_id: input_boolean.sem_use_official_nordpool
#        state: "on"
    action:
      - action: nordpool.get_prices_for_date
        data:
          config_entry: "{{ states('input_text.sem_nordpool_config_entry_official') }}"
          date: "{{ now().date() }}"
          areas: "{{ states('input_text.sem_nordpool_area_official') }}"
          currency: SEK
        response_variable: today_price
      - action: nordpool.get_prices_for_date
        data:
          config_entry: "{{ states('input_text.sem_nordpool_config_entry_official') }}"
          date: "{{ now().date() + timedelta(days=1) }}"
          areas: "{{ states('input_text.sem_nordpool_area_official') }}"
          currency: SEK
        response_variable: tomorrow_price
    sensor:
      - name: "sem_nordpool_sensor_official"
        unique_id: sem_nordpool_sensor_official
        state: "{{ (today_price[today_price.keys()| list | first] | selectattr('start', '<=', utcnow().strftime('%Y-%m-%dT%H:%M:%S+00:00')) | map(attribute='price') | list | last | float/1000) | round(4) }}"
        attributes:
          region: "{{ states('input_text.sem_nordpool_area_official') }}"
          additional_costs_current_hour: "0"
          price_in_cents: "false"
          unit: "kWh"
          currency: "SEK"
          country: "Sweden"
          average: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region] | map(attribute='price') | map('float') | sum / (today_price[region] | length) / 1000) | round(3) }}
          off_peak_1: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region][0:4] | map(attribute='price') | map('float') | sum / 4 / 1000) | round(3) }}
          off_peak_2: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region][-2:] | map(attribute='price') | map('float') | sum / 2 / 1000) | round(3) }}
          peak: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region][4:-2] | map(attribute='price') | map('float') | sum / ((today_price[region]|length)-6) / 1000) | round(3) }}
          min: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region] | map(attribute='price') | map('float') | min / 1000) | round(3) }}
          max: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region] | map(attribute='price') | map('float') | max / 1000) | round(3) }}
          mean: >
            {%- set region = this.attributes.get('region') -%}
            {{ (today_price[region] | map(attribute='price') | map('float') | sum / (today_price[region] | length) / 1000) | round(3) }}
          low_price: >
            {%- set region = this.attributes.get('region') -%}
            {% set prices = today_price[region] | map(attribute='price') | map('float') | list %}
            {{ (prices[0] < (prices | sum / prices | length)) }}
          price_percent_to_average: >
            {%- set region = this.attributes.get('region') -%}
            {% set prices = today_price[region] | map(attribute='price') | map('float') | list %}
            {{ (prices[0] / (prices | sum / prices | length) | round(2)) }}
          today: >
            {%- set region = this.attributes.get('region') -%}
            {{ today_price[region] | map(attribute='price') | map('float') | map('multiply',0.001) | list }}
          tomorrow: >
            {%- set region = this.attributes.get('region') -%}
            {{ tomorrow_price[region] | map(attribute='price') | map('float') | map('multiply',0.001) | list }}
          raw_today: >
            {%- set region = this.attributes.get('region') -%}
            [
            {%- for p in today_price[region] -%}
              {"start": "{{ p.start }}", "end": "{{ p.end }}", "value": {{ (p.price | float / 1000) | round(3) }}}{% if not loop.last %},{% endif %}
            {%- endfor -%}
            ]
          raw_tomorrow: >
            {%- set region = this.attributes.get('region') -%}
            [
            {%- for p in tomorrow_price[region] -%}
              {"start": "{{ p.start }}", "end": "{{ p.end }}", "value": {{ (p.price | float / 1000) | round(3) }}}{% if not loop.last %},{% endif %}
            {%- endfor -%}
            ]
          current_price: >
            {%- set region = this.attributes.get('region') -%}
            {%- set now_utc = utcnow().strftime('%Y-%m-%dT%H:%M:%S+00:00') -%}
            {%- set current_prices = today_price[region] -%}
            {%- set current = current_prices | selectattr('start','<=', now_utc) | list | last -%}
            {{ (current.price | float / 1000) | round(4) if current else 0 }}
          tomorrow_valid: >
            {%- set region = this.attributes.get('region') -%}
            {{ (tomorrow_price[region] | length > 0) | bool }}


  - trigger:
    # Trigger 1: När nuvarande 1A-intervall är slut och morgondagens priser finns
    - trigger: template
      value_template: >
        {%- set window = states('sensor.sem_battery_charge_window_cheapest_1a') -%}
        {%- set tomorrow_available = is_state('binary_sensor.sem_nordpool_tomorrow_prices_available', 'on') -%}

        {%- if window not in ['none', 'unknown', 'unavailable', ''] -%}
          {%- set parts = window.split(' - ') -%}
          {%- if parts | length == 2 -%}
            {%- set end = parts[1] | as_datetime -%}
            {{ now() > end and tomorrow_available }}
          {%- else -%}
            false
          {%- endif -%}
        {%- else -%}
          false
        {%- endif -%}
    # Trigger 2: Klockan 18:00 varje dag
    - trigger: time
      at: '18:00:00'
    sensor:
      - name: "sem_battery_charge_window_cheapest_1a"
        state: >
          {%- set duration = states('sensor.sem_battery_dynamic_charge_time_window_1') | float(0) %}
          {%- set duration_quarters = (duration * 4) | int %}
          {%- set nordpool_sensor_id = states('sensor.sem_nordpool_sensor_id') %}
          {%- set prices_tomorrow = state_attr(nordpool_sensor_id, 'raw_tomorrow') or [] %}

          {%- if prices_tomorrow | length >= (16-9)*4 %}
            {%- set base_date = (now() + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0) %}
            {%- set start_index = 9 * 4 %}
            {%- set end_index = (16 * 4) - duration_quarters %}

            {%- set ns = namespace(min_avg=None, start_index=None) %}
            {%- for i in range(start_index, end_index + 1) %}
              {%- set slice = prices_tomorrow[i:i + duration_quarters] %}
              {%- if slice | length == duration_quarters %}
                {%- set values = slice | map(attribute='value') | list %}
                {%- set avg = (values | sum) / duration_quarters %}
                {%- if ns.min_avg is none or avg < ns.min_avg %}
                  {%- set ns.min_avg = avg %}
                  {%- set ns.start_index = i %}
                {%- endif %}
              {%- endif %}
            {%- endfor %}

            {%- if ns.start_index is not none %}
              {%- set start_time = (base_date + timedelta(minutes=ns.start_index*15)).astimezone() %}
              {%- set end_time = start_time + timedelta(minutes=duration_quarters*15) %}
              {{ start_time.isoformat() ~ ' - ' ~ end_time.isoformat() }}
            {%- else %}
              unavailable
            {%- endif %}
          {%- else %}
            unavailable
          {%- endif %}
        
  - trigger:
    # Trigger 1: Klockan 06:00 varje dag
      - trigger: time
        at: '06:00:00'
    # Trigger 2: När morgondagens priser blir tillgängliga
      - trigger: state
        entity_id: binary_sensor.sem_nordpool_tomorrow_prices_available
        to: 'on'
    sensor:
      - name: "sem_battery_charge_window_cheapest_2"
        state: >
          {%- set duration = states('sensor.sem_battery_dynamic_charge_time_window_2') | float(0) %}
          {%- set numberOfSequentialQuarters = (duration * 4) | int %}
          {%- set nordpool_sensor_id = states('sensor.sem_nordpool_sensor_id') %}
          {%- set tomorrow_available = is_state('binary_sensor.sem_nordpool_tomorrow_prices_available', 'on') %}

          {%- if not tomorrow_available %}
            {# Fast intervall 02:00–04:00 #}
            {%- set base_date = (now() + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0) %}
            {%- set start_time = base_date + timedelta(hours=2) %}
            {%- set end_time = start_time + timedelta(hours=2) %}
            {{ start_time.isoformat() ~ ' - ' ~ end_time.isoformat() }}

          {%- else %}
            {# Hämta priser #}
            {%- set prices_today = state_attr(nordpool_sensor_id, 'raw_today') or [] %}
            {%- set prices_tomorrow = state_attr(nordpool_sensor_id, 'raw_tomorrow') or [] %}

            {# Filtrera priser: idag 23:00+ och imorgon 00–05 #}
            {%- set prices_today_filtered = prices_today[23*4:] %}
            {%- set prices_tomorrow_filtered = prices_tomorrow[0:5*4] %}
            {%- set combined_prices = prices_today_filtered + prices_tomorrow_filtered %}

            {%- set ns = namespace(min_avg=None, start_index=None) %}
            {%- for i in range(0, combined_prices | length - numberOfSequentialQuarters + 1) %}
              {%- set slice = combined_prices[i:i + numberOfSequentialQuarters] %}
              {%- set avg = (slice | map(attribute='value') | sum) / numberOfSequentialQuarters %}
              {%- if ns.min_avg is none or avg < ns.min_avg %}
                {%- set ns.min_avg = avg %}
                {%- set ns.start_index = i %}
              {%- endif %}
            {%- endfor %}

            {%- if ns.start_index is not none %}
              {%- set start_obj_index = ns.start_index %}
              {%- set end_obj_index = ns.start_index + numberOfSequentialQuarters %}  {# FIX här: ta bort -1 #}

              {# Beräkna start och sluttid #}
              {%- set base_date = now().replace(hour=0, minute=0, second=0, microsecond=0) %}
              {%- if start_obj_index < prices_today_filtered | length %}
                {# Start idag #}
                {%- set start_time = base_date + timedelta(hours=23) + timedelta(minutes=15*start_obj_index) %}
              {%- else %}
                {# Start imorgon #}
                {%- set start_time = base_date + timedelta(days=1) + timedelta(minutes=15*(start_obj_index - prices_today_filtered | length)) %}
              {%- endif %}

              {%- if end_obj_index < prices_today_filtered | length %}
                {%- set end_time = base_date + timedelta(hours=23) + timedelta(minutes=15*end_obj_index) %}
              {%- else %}
                {%- set end_time = base_date + timedelta(days=1) + timedelta(minutes=15*(end_obj_index - prices_today_filtered | length)) %}
              {%- endif %}

              {{ start_time.isoformat() ~ ' - ' ~ end_time.isoformat() }}
            {%- else %}
              Ingen giltigt intervall hittades
            {%- endif %}
          {%- endif %}
  
  # WEATHER FORCECAST DAILY
  - trigger:
      - trigger: time_pattern
        minutes: "/5"
      - trigger: homeassistant
        event: start
    action:
      - variables:
          weather_entity: "{{ states('input_text.sem_weather_sensor') }}"
      - action: weather.get_forecasts
        data:
          type: daily
        target:
          entity_id: "{{weather_entity}}"
        response_variable: weather_home_daily
    sensor:
      - name: "sem_weather_forecasts"
        state: "{{ states(weather_entity) }}"
        attributes:
          forecast: "{{ weather_home_daily[weather_entity].forecast }}"

  # WEATHER FORCECAST HOURLY       
  - trigger:
      - trigger: time_pattern
        minutes: "/5"
      - trigger: homeassistant
        event: start
    action:
      - variables:
          weather_entity: "{{ states('input_text.sem_weather_sensor') }}"
      - action: weather.get_forecasts
        data:
          type: hourly
        target:
          entity_id: "{{weather_entity}}"
        response_variable: weather_home_hourly
    sensor:
      - name: "sem_weather_forecasts_hourly"
        state: "{{ states(weather_entity) }}"
        attributes:
          forecast: "{{ weather_home_hourly[weather_entity].forecast }}"

  # STORE LOWEST TEMP
  - trigger:
      - trigger: time
        at: "00:03:00" 
    sensor:
      - name: "sem_temp_low"
        state: >
          {# Hämta dagens lägsta temperatur från SMHI #}
          {% set forecast = state_attr('sensor.sem_weather_forecasts_hourly', 'forecast') %}
          {% if forecast %}
            {% set today_low = forecast | map(attribute='templow') | map('float') | min %}
            {{ today_low }}
          {% else %}
            {{ states('sensor.sem_temp_low') }}
          {% endif %}
        attributes:
          yesterday: >
            {% set yesterday = state_attr('sensor.sem_temp_low', 'today') %}
            {{ yesterday if yesterday is not none else 0 }}
          day_before_yesterday: >
            {% set db_yesterday = state_attr('sensor.sem_temp_low', 'yesterday') %}
            {{ db_yesterday if db_yesterday is not none else 0 }}
          today: >
            {% set forecast = state_attr('sensor.sem_weather_forecasts_hourly', 'forecast') %}
            {% if forecast %}
              {{ forecast | map(attribute='templow') | map('float') | min }}
            {% else %}
              {{ states('sensor.sem_temp_low') }}
            {% endif %}
          source: sensor.sem_weather_forecasts_hourly


#CHECKS IF ELECTRIC PRICES ARE AVALIBLE
  - binary_sensor:
      - name: "sem_nordpool_tomorrow_prices_available"
        unique_id: "sem_nordpool_tomorrow_prices_available"
        state: >
          {% if is_state('input_boolean.sem_use_official_nordpool', 'on') %}
            {{ state_attr('sensor.sem_nordpool_sensor_official', 'tomorrow_valid') == true }}
          {% else %}
            {% set sensor_id = states('input_text.sem_nordpool_sensor_inofficial') %}
            {% if sensor_id %}
              {{ state_attr(sensor_id, 'tomorrow_valid') == true }}
            {% else %}
              false
            {% endif %}
          {% endif %}
